#ifndef ENVIRONMENT_HXX_INCLUDED
#define ENVIRONMENT_HXX_INCLUDED

#include <cassert>
#include <format>
#include <map>
#include <memory>
#include <string>

#include "runtime_error.hxx"
#include "token.hxx"
#include "object/object.hxx"

class Environment;
using EnvironmentPtr = std::shared_ptr<Environment>;

class Environment
{
	friend class GarbageCollector; // values

public:
	Environment(EnvironmentPtr encolsing_env = nullptr)
		: enclosing(encolsing_env)
	{
	}

	void define(const std::string &name, const Object &value)
	{
		values[name] = value;
	}

	void assign(const Token &name, const Object &value)
	{
		auto result = values.find(std::string(name.lexeme));
		if (result != values.end()) {
			result->second = value;
			return;
		}

		if (enclosing != nullptr) {
			enclosing->assign(name, value);
			return;
		}

		throw RuntimeError(
			name, std::format("Undefined variable '{}'.", name.lexeme)
		);
	}

	Object get(const Token &name)
	{
		auto result = values.find(std::string(name.lexeme));
		if (result != values.end())
			return result->second;

		if (enclosing != nullptr)
			return enclosing->get(name);

		throw RuntimeError(
			name, std::format("Undefined variable '{}'.", name.lexeme)
		);
	}

	// Returns the object stored in the distance number of enclosing scopes away.
	// The variable being accesed must exist in the scope,
	// so only access using the data from the side-table generated by Resolver
	Object get_at(int distance, const std::string &name)
	{
		return ancestor(*this, distance).values.at(name);
	}

	// Assigns the object stored in the distance number of enclosing scopes away.
	// The variable being assigned must exist in the scope,
	// so only access using the data from the side-table generated by Resolver
	void assign_at(int distance, const Token &name, const Object &value)
	{
		ancestor(*this, distance).values.at(name.lexeme) = value;
	}

	EnvironmentPtr enclosing;

private:
	static Environment &ancestor(Environment &env, int distance)
	{
		if (distance == 0)
			return env;

		assert(env.enclosing != nullptr);
		return ancestor(*env.enclosing, distance - 1);
	}

	std::map<const std::string, Object> values;
	// For mark and sweep garbage collector
	bool reachable = false;
};

#endif